using Juice.Domain;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Juice.EF.Extensions
{
    public static class AuditableDbContextExtensions
    {
        public static void SetAuditInformation<TContext>(this TContext context, ILogger? logger = default)
            where TContext : DbContext, IAuditableDbContext
        {
            try
            {
                var addedEntities = context.ChangeTracker.Entries<IAuditable>().Where(entry => entry.State == EntityState.Added).ToList();
                var user = context.User;

                addedEntities.ForEach(entry =>
                {
                    entry.Entity.SetOnceCreatedUser(user);

                    entry.Entity.UpdateModifiedUser(user);
                });

                var editedEntities = context.ChangeTracker.Entries<IAuditable>().Where(entry => entry.State == EntityState.Modified).ToList();

                editedEntities.ForEach(entry =>
                {
                    entry.Property(nameof(IAuditable.CreatedDate)).IsModified = false;
                    entry.Property(nameof(IAuditable.CreatedUser)).IsModified = false;
                    entry.Property(nameof(IAuditable.ModifiedDate)).CurrentValue = DateTimeOffset.Now;

                    entry.Entity.UpdateModifiedUser(user);

                });

            }
            catch (Exception ex)
            {
                logger?.LogWarning(ex, $"[DbContextBase][SetAuditInformation][Failed] {ex.StackTrace}");
            }
        }

        public static IEnumerable<AuditEntry>? TrackingChanges<TContext>(this TContext context, ILogger? logger = default)
            where TContext : DbContext, IAuditableDbContext
        {
            try
            {
                if (context.AuditHandlers?.Any() ?? false)
                {
                    context.ChangeTracker.DetectChanges();
                    var user = context.User;
                    var auditEntries = new List<AuditEntry>();
                    foreach (var entry in context.ChangeTracker.Entries())
                    {
                        if (entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                        {
                            continue;
                        }

                        var auditEntry = new AuditEntry(entry)
                        {
                            Table = entry.Metadata?.GetTableName(),
                            Database = context.Database.GetDbConnection().Database,
                            Schema = entry.Metadata?.GetSchema(),
                            User = user,
                            DataEvent = entry.State == EntityState.Added ? DataEvents.Inserted
                            : entry.State == EntityState.Deleted ? DataEvents.Deleted
                            : entry.State == EntityState.Modified ? DataEvents.Modified
                            : null
                        };
                        if (auditEntry.DataEvent == null) { continue; }

                        auditEntries.Add(auditEntry);

                        var tableIdentifier = entry.Metadata != null ? StoreObjectIdentifier.Create(entry.Metadata, StoreObjectType.Table)
                            : default;
                        foreach (var property in entry.Properties)
                        {
                            if (property.IsTemporary)
                            {
                                // value will be generated by the database, get the value after saving
                                auditEntry.TemporaryProperties.Add(property);
                                continue;
                            }

                            var propertyName = property.Metadata.Name;
                            if (property.Metadata.IsPrimaryKey())
                            {
                                auditEntry.KeyValues[propertyName] = property.CurrentValue;
                                continue;
                            }

                            switch (entry.State)
                            {
                                case EntityState.Added:
                                    if (entry.Entity is IExpandable expandable
                                            && tableIdentifier.HasValue
                                            && property.Metadata.GetColumnName(tableIdentifier.Value) == "Properties")
                                    {
                                        foreach (var kvp in expandable.CurrentPropertyValues)
                                        {
                                            auditEntry.CurrentValues[kvp.Key] = kvp.Value;
                                        }

                                        break;
                                    }
                                    auditEntry.CurrentValues[propertyName] = property.CurrentValue;
                                    break;

                                case EntityState.Deleted:
                                    auditEntry.OriginalValues[propertyName] = property.OriginalValue;
                                    break;

                                case EntityState.Modified:
                                    if (property.IsModified)
                                    {
                                        if ((property.CurrentValue == null && property.OriginalValue == null)
                                            || (property.CurrentValue != null && property.OriginalValue != null
                                            && property.CurrentValue.Equals(property.OriginalValue))
                                            || property.Metadata.Name == nameof(IAuditable.CreatedDate)
                                            || property.Metadata.Name == nameof(IAuditable.CreatedUser)
                                            || property.Metadata.Name == nameof(IAuditable.ModifiedDate)
                                            || property.Metadata.Name == nameof(IAuditable.ModifiedUser)
                                            )
                                        {
                                            break;
                                        }
                                        // handle for expanable entity based on JSON column
                                        if (entry.Entity is IExpandable expandable1
                                            && tableIdentifier.HasValue
                                            && property.Metadata.GetColumnName(tableIdentifier.Value) == "Properties")
                                        {
                                            foreach (var kvp in expandable1.OriginalPropertyValues)
                                            {
                                                if (expandable1.CurrentPropertyValues.ContainsKey(kvp.Key) && expandable1.CurrentPropertyValues[kvp.Key] != kvp.Value)
                                                {
                                                    auditEntry.OriginalValues[kvp.Key] = kvp.Value;
                                                    auditEntry.CurrentValues[kvp.Key] = expandable1.CurrentPropertyValues[kvp.Key];
                                                }
                                            }

                                            break;
                                        }
                                        auditEntry.OriginalValues[propertyName] = property.OriginalValue;
                                        auditEntry.CurrentValues[propertyName] = property.CurrentValue;
                                    }
                                    break;
                            }
                        }
                    }
                    return auditEntries;
                }
            }
            catch (Exception ex)
            {
                logger?.LogDebug(ex, "[DbContextBase][TrackingChanges][Failed]");
            }
            return null;
        }


        public static void NotificationChanges<TContext>(this TContext context, IEnumerable<AuditEntry> auditEntries, ILogger? logger = default)
             where TContext : DbContext, IAuditableDbContext
        {
            try
            {
                if ((context.AuditHandlers?.Any() ?? false) && auditEntries != null && auditEntries.Any())
                {
                    foreach (var auditEntry in auditEntries)
                    {
                        // Get the final value of the temporary properties
                        foreach (var prop in auditEntry.TemporaryProperties)
                        {
                            if (prop.Metadata.IsPrimaryKey())
                            {
                                auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                            }
                            else
                            {
                                auditEntry.CurrentValues[prop.Metadata.Name] = prop.CurrentValue;
                            }
                        }
                        if (auditEntry.DataEvent != null)
                        {
                            // Save the Audit entry
                            foreach (var handler in context.AuditHandlers)
                            {
                                try
                                {
                                    handler.HandleAsync(auditEntry.DataEvent.Create(auditEntry.ToAudit())).GetAwaiter().GetResult();
                                }
                                catch (Exception ex)
                                {
                                    logger?.LogWarning(ex, $"[DbContextBase] failed to handle audit event on {handler.GetType().FullName}. {ex.Message}");
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                logger?.LogWarning(ex, "[DbContextBase][NotificationChanges] {0}", ex.Message);
            }
        }


        public static bool HasUnsavedChanges<TContext>(this TContext context)
            where TContext : DbContext
        {
            return context.ChangeTracker.Entries().Any(e => e.State == EntityState.Added
                                                     || e.State == EntityState.Modified
                                                     || e.State == EntityState.Deleted);
        }

        public static async Task<(int Affected, HashSet<EntityEntry> RefreshEntries)> TryUpdateDynamicPropertyAsync<TContext>(this TContext context,
            ILogger? logger = default)
            where TContext : DbContext
        {
            var (refresh, updates, args) = await context.GetExpandablePropertiesUpdateSqlAsync(logger);
            if (updates.Any())
            {
                var sql = string.Join(";", updates);
                var affects = context.Database.ExecuteSqlRaw(sql, args);

                return (affects, refresh);
            }
            else
            {
                return (0, refresh);
            }
        }

        public static async Task<(HashSet<EntityEntry> refresh, IEnumerable<string> SQL, object[] ARGs)> GetExpandablePropertiesUpdateSqlAsync<TContext>(this TContext context, ILogger? logger = default)
            where TContext : DbContext
        {
            await Task.Yield();
            var _refreshEntries = new HashSet<EntityEntry>();

            var editedEntities = context.ChangeTracker.Entries<IExpandable>().Where(entry => entry.State == EntityState.Modified).ToList();
            var updates = new List<string>();
            var args = new List<object>();
            foreach (var entry in editedEntities)
            {
                var tableIdentifier = StoreObjectIdentifier.Create(entry.Metadata, StoreObjectType.Table);
                if (tableIdentifier.HasValue)
                {
                    // Finding property that map to Properties column
                    var colName = "Properties";
                    var property = entry.Properties.Where(p => p.Metadata.GetColumnName(tableIdentifier.Value) == colName).FirstOrDefault();
                    if (property != null)
                    {
                        property.IsModified = false;
                        _refreshEntries.Add(entry);
                        var expandable = entry.Entity;

                        // Get Key value
                        var primaryKey = entry.Metadata.FindPrimaryKey();
                        var keyProp = primaryKey?.Properties?.Select(p => p.PropertyInfo)?.Single();
                        var keyColumn = primaryKey?.Properties?.Select(p => p.GetColumnName(tableIdentifier.Value))?.Single();
                        var key = keyProp?.GetValue(expandable, null);
                        if (key != null && !string.IsNullOrEmpty(keyColumn))
                        {
                            foreach (var kvp in expandable.OriginalPropertyValues)
                            {
                                var currentValue = expandable.CurrentPropertyValues[kvp.Key];
                                if (currentValue != kvp.Value)
                                {
                                    var value = JsonConvert.SerializeObject(currentValue);
                                    var sql = "";

                                    var token = JToken.Parse(value);

                                    if (token is JArray || token is JObject)
                                    {
                                        value = token.ToString(Formatting.None);
                                        sql = $"Update {entry.Metadata.GetSchema()}.[{entry.Metadata.GetTableName()}] set {colName}=JSON_MODIFY({colName}, '$.\"{kvp.Key}\"', JSON_QUERY  ({{{args.Count}}})) where {keyColumn} = {{{args.Count + 1}}}";
                                    }
                                    else
                                    {
                                        value = value.Trim('"');
                                        sql = $"Update {entry.Metadata.GetSchema()}.[{entry.Metadata.GetTableName()}] set {colName}=JSON_MODIFY({colName}, '$.\"{kvp.Key}\"', {{{args.Count}}}) where {keyColumn} = {{{args.Count + 1}}}";
                                    }

                                    updates.Add(sql);
                                    args.Add(value);
                                    args.Add(key);
                                    if (logger?.IsEnabled(LogLevel.Debug) ?? false)
                                    {
                                        logger?.LogDebug(sql);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return (_refreshEntries, updates, args.ToArray());
        }


        #region Expandable entity based on JSON column

        public static async Task RefreshEntriesAsync(this HashSet<EntityEntry> refreshEntries)
        {
            if (refreshEntries.Any())
            {
                foreach (var entry in refreshEntries)
                {
                    await entry.ReloadAsync();
                }
            }
        }

        #endregion
    }
}
